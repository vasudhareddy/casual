import org.springframework.stereotype.Component;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import jakarta.validation.Valid;
import java.util.ArrayList;
import java.util.List;

public class BaseOpsValidator {

    private static final Pattern VALID_NAME_PATTERN = Pattern.compile("^[a-zA-Z ']+$");

    public void validateOnlyStringLength(String attributeValue, int minLength, int maxLength, String fieldName, List<String> errors) {
        if (attributeValue != null && attributeValue.length() < minLength) {
            errors.add(fieldName + " must be at least " + minLength + " characters long.");
        } else if (attributeValue != null && attributeValue.length() > maxLength) {
            errors.add(fieldName + " must be at most " + maxLength + " characters long.");
        }
    }

    public void validateRequiredString(String attributeValue, int minLength, int maxLength, String fieldName, List<String> errors) {
        if (attributeValue == null || attributeValue.length() < minLength) {
            errors.add(fieldName + " is required and must be at least " + minLength + " characters long.");
        } else if (attributeValue.length() > maxLength) {
            errors.add(fieldName + " must be at most " + maxLength + " characters long.");
        }
    }

    public void validateRequiredStringForAlphaSpace(String attributeValue, String fieldName, List<String> errors) {
        if (!VALID_NAME_PATTERN.matcher(attributeValue).matches()) {
            errors.add(fieldName + " contains invalid characters. Only letters and spaces are allowed.");
        }
    }

    public void validateRequiredDate(String dateAsString, String fieldName, List<String> errors) {
        try {
            Date date = DateUtil.parseDate(dateAsString);
            if (!(dateAsString.equals(DateUtil.formatDate(date, "MM/dd/yyyy")) ||
                  dateAsString.equals(DateUtil.formatDate(date, "MM-dd-yyyy")) ||
                  dateAsString.equals(DateUtil.formatDate(date, "yyyy/MM/dd")) ||
                  dateAsString.equals(DateUtil.formatDate(date, "yyyy-MM-dd")))) {
                errors.add(fieldName + " has an invalid date format.");
            }
        } catch (Exception t) {
            errors.add(fieldName + " has an invalid date format.");
        }
    }

    public void checkNameStringRequirements(String attributeValue, int minLength, int maxLength, String fieldName, List<String> errors) {
        if (attributeValue == null || attributeValue.isBlank()) {
            errors.add(fieldName + " is required.");
        } else {
            int alphaCount = 0;
            for (char c : attributeValue.toCharArray()) {
                if (Character.isAlphabetic(c)) {
                    alphaCount++;
                }
            }

            if (alphaCount < minLength) {
                errors.add(fieldName + " must contain at least " + minLength + " alphabetic characters.");
            } else if (attributeValue.length() > maxLength) {
                errors.add(fieldName + " must not exceed " + maxLength + " characters.");
            }
        }
    }

    public void checkRequiredEmailAddress(String emailAddress, String fieldName, List<String> errors) {
        try {
            if (!EmailUtil.isValidEmailAddress(emailAddress)) {
                errors.add(fieldName + " has an invalid email address.");
            }
        } catch (Exception e) {
            errors.add(fieldName + " has an invalid email address.");
        }
    }

    public void checkStartEndDates(Date startDate, Date endDate, String fieldName, List<String> errors) {
        if (startDate != null && endDate != null) {
            if (startDate.after(endDate) || startDate.equals(endDate)) {
                errors.add(fieldName + " start date must be before the end date.");
            }
        }
    }
}

@Component
@Validated
public class LoanSearchFormValidator {

    private static final Pattern DIGIT_PATTERN = Pattern.compile("\\d+");

    private final BaseOpsValidator baseOpsValidator;

    public LoanSearchFormValidator(BaseOpsValidator baseOpsValidator) {
        this.baseOpsValidator = baseOpsValidator;
    }

    public List<String> validate(@Valid LoanSearchForm loanSearchForm) {
        List<String> errors = new ArrayList<>();

        if (LoanSearchForm.isSearchTypeByLastNameSSN()) {
            baseOpsValidator.validateRequiredString(loanSearchForm.getSsn(), 4, 30, "SSN", errors);
            baseOpsValidator.validateRequiredStringForAlphaSpace(loanSearchForm.getFirstName(), "First Name", errors);
            baseOpsValidator.validateRequiredStringForAlphaSpace(loanSearchForm.getLastName(), "Last Name", errors);
            baseOpsValidator.checkNameStringRequirements(loanSearchForm.getFirstName(), 1, 30, "First Name", errors);
            baseOpsValidator.checkNameStringRequirements(loanSearchForm.getLastName(), 1, 30, "Last Name", errors);
            if (!DIGIT_PATTERN.matcher(loanSearchForm.getSsn()).matches()) {
                errors.add("SSN must contain only digits.");
            }
        }

        baseOpsValidator.validateOnlyStringLength(loanSearchForm.getLoanNumber(), 1, 10, "Loan Number", errors);

        if (loanSearchForm.getLoanNumber() != null && !loanSearchForm.getLoanNumber().isEmpty()) {
            if (!DIGIT_PATTERN.matcher(loanSearchForm.getLoanNumber()).matches()) {
                errors.add("Loan Number must contain only digits.");
            }
        }

        if (!loanSearchForm.getLoanNumber().equals(loanSearchForm.getPreviousLoanNumber()) && loanSearchForm.isPostalCodeRequired()) {
            baseOpsValidator.validateOnlyStringLength(loanSearchForm.getPostalCode(), 5, 5, "Postal Code", errors);
        } else {
            loanSearchForm.setPostalCodeRequired(false);
        }

        baseOpsValidator.checkRequiredStringContainsIntegersOnly(loanSearchForm.getPostalCode(), "Postal Code", errors);

        loanSearchForm.setPreviousLoanNumber(loanSearchForm.getLoanNumber());

        return errors;
    }
}

@RestController
@RequestMapping("/loan")
public class LoanSearchController {

    private final LoanSearchFormValidator loanSearchFormValidator;

    public LoanSearchController(LoanSearchFormValidator loanSearchFormValidator) {
        this.loanSearchFormValidator = loanSearchFormValidator;
    }

    @PostMapping("/loanSearch")
    public ResponseEntity<?> searchByLoan(@Valid @RequestBody LoanSearchForm loanSearchForm) {
        List<String> errors = loanSearchFormValidator.validate(loanSearchForm);
        if (!errors.isEmpty()) {
            return ResponseEntity.badRequest().body(errors);
        }
        return ResponseEntity.ok("Validation successful.");
    }
}
